<!DOCTYPE html>
<html>
    <head>            
        <link rel="stylesheet" href="/learn-to-code/content/theme.css">
    </head>
    <body>
        <aside>Learn to Code - Web Edition: JavaScript</aside>
        <h1>Code a Game - Part 1</h1>
        <p>Let's make a browser based game using the <code>canvas</code> HTML element. 
            On the left is the basic structure we need to get started where the setInterval method at the bottom lets us set how often our main loop should be executed in milliseconds. 
            There are 1000 milliseconds in a second so we can divide 1000 by the framerate constant to get a nice smooth 60 frames a second..</p> 
            <p><i>NOTE: A constant <code>const</code> can be used like other variables except you can assign a new value to them so their value is constant.</i></p>
        <p>All the code does so far is move a square across to the right forever.</p>
        <p><i>NOTE: Have you noticed the lines that start with <code>//something...</code></i>? These are called comments and they are very useful for making notes in your code to remind yourself of how or why things are there. They are completely ignored by the JavaScript interpreter so use them as much as you need.</p>
        <h2>Full Screen</h2>
        <p>The <code>canvas</code> element defaults size is quite small so let's make it fill the page using a combination of size and scale. 
            Define another constant in the <code>Define constants</code> section of code. This value will be used to configure the canvas scale so that the shapes have nice smooth edges.</p>
        <pre><code>
const SCALE = 2
        </code></pre>
        <p>Add the following, to the top of the <code>Set up canvas</code> section of code, to tell the canvas to stretch to the size and scale of the whole page:</p>
        <pre><code>
canvas.width = window.innerWidth * SCALE
canvas.height = window.innerHeight * SCALE
canvas.style.width = `${window.innerWidth}px`
canvas.style.height = `${window.innerHeight}px`
        </code></pre>
        <p>If you run the code you will see that there is still bit of white space between the edges of the page and the canvas but we can remove that using CSS with a new selector and declarations in the <code>&lt;style&gt;</code> tag.</p>   
        <pre><code>
body {
    margin: 0;
    overflow: hidden;
}
        </code></pre>   
        <p>And now that our canvas is full screen we don't need to style a border any more so we can set the canvas border to 0:</p>          
        <pre><code>
<i>canvas {
    border:</i> 0<i>;
}</i>
        </code></pre> 
        <h2>Check for walls</h2>
        <p>Let's make it so that if the box gets the right of the screen then it bounces back. We can do this by:</p>
        <ul>
            <li>Adding a velocity variable to our ball. And let's set it to 5 to speed things up a bit. 
                <pre><code>
<i>let ball = {x: 1</i>, xV: 5<i>}</i>
                </code></pre>
            </li>
            <li>Adding an <code>if</code> condition into our loop function. The <code>Update values</code> section can change to:
            <pre><code>
<i>//Update values</i>
if (ball.x > canvas.width) {
    ball.x = canvas.width
    ball.xV = -ball.xV
} 
<i>ball.x = ball.x +</i> ball.xV  
            </code></pre>
            <i>NOTE: After checking if the ball has gone past the edge, we can force the <code>ball.x</code> position so that it sits perfectly against the edge. 
            Also you may be wondering about the line <code>ball.xV = -ball.xV</code>. This inverts the velocity value so if <code>xV</code> is 10 then <code>xV</code> is set to negative itself so -10 which will move the box left.</i></li>
        </ul>
        <p>Now the box drops off the left of the screen so let's add another condition after the first one.</p>
        <pre><code>
<i>//Update values
if (ball.x > canvas.width) {
    ball.x = canvas.width
    ball.xV = -ball.xV
}</i> 
if (ball.x < 0) {
    ball.x = 0
    ball.xV = -ball.xV
}
<i>ball.x = ball.x + ball.xV</i>
        </code></pre>
        <p><i>NOTE: You can see the same <code>ball.xV = -ball.xV</code> expression being used here. This still works because id <code>xV</code> is -10 then the expression resolves to <code>ball.xV = -(-10)</code> and because a negative of a negative is a positive our box will start heading to the right again.</i></p>
        <h2>Boxes are boring</h2>
        <p>Let's draw an image rather than a box by:</p>
        <ul>
            <li>Adding and loading an image in our <code>Define variables</code> section: 
                <pre><code>
let ballImage = new Image()
ballImage.src = "https://code.qantas.com/learn-to-code/images/ball.png"
                </code></pre></li>
            <li>Drawing the image onto the canvas by updating the line that does a <code>fillRect</code> with:
                <pre><code>
<i>canvasContext.</i>drawImage(ballImage,<i> ball.x, 30, BALLSIZE, BALLSIZE)</i>
                </code></pre>
                Where the parameters are drawImage(image, left, top, width, height)
            </li>
        </ul>
        <p>You may notice that the ball still goes off the right hand side a bit before bouncing back. This is because the coordinate system of the canvas draws things from the top left corner of the window to the top left corner of the image which means we are checking if the left edge of the image has reached the wall. We can fix this by subtracting the ball width from the window width in our <code>if</code> condition:</p>
        <pre><code>
<i>if (ball.x > canvas.width</i> - BALLSIZE<i>) {
    ball.x = canvas.width</i> - BALLSIZE
    <i>etc...</i>
        </code></pre>
        <p><i>NOTE: It's still a good idea to force the ball completely back into view so having checked that the ball has gone too far we can set it to the right hand edge minus it's width.</i></p>
        <h2>Add some gravity</h2>
        <p>In real life gravity is a constant force that applies a velocity of 9.8 meters per second. We can use a <code>const</code> to set a constant for gravity in our <code>Define constants</code> section of code.</p>        
        <p>We can use a momentum constant to specify how much bounce the ball has. A value just less than 1 will mean that the amount of momentum the ball carries should be slightly reduced each bounce due to friction.</p>
        <pre><code>
const GRAVITY = 9.8
const MOMENTUM = 0.98
        </code></pre>
        <p>To get things moving in an up and down way we need some more values in our ball object to handle vertical position <code>ball.y</code> and vertical velocity <code>yV</code>. Let's update our code to:</p>
        <pre><code>
<i>let ball = {x: 1, xV: 5</i>, y: 30, yV: 0<i>}</i>
        </code></pre>
        <p>Next we can add the top of our <code>Update values</code> section in our main loop to apply the gravity to the vertical position of the ball.</p>
        <pre><code>
ball.yV = ball.yV + GRAVITY / FRAMERATE  
        </code></pre>
        <p>NOTE: We need to divide gravity by the frame rate because our constant value is gravity's affect per second but we are updating our values about 60 times per second.</p>
        <p>And then to the end of the <code>Update values</code> section to set the <code>ball.y</code> position with the calculated vertical velocity <code>ball.yV</code>.</p>
        <pre><code>
ball.y = ball.y + ball.yV
        </code></pre>
        <p>And finally update the drawImage code to use our new <code>ball.y</code> variable.</p>
        <pre><code>
<i>canvasContext.drawImage(ballImage, ball.x,</i> ball.y<i>, BALLSIZE, BALLSIZE)</i>
        </code></pre>
        <h2>Bounce off the floor</h2>
        <p>So the ball is now dropping through the floor but we can use the same technique as we did for the walls with an extra condition. Just before we update <code>ball.y</code> value add:</p>
        <pre><code>
if (ball.y > canvas.height - BALLSIZE) {
    ball.y = canvas.height - BALLSIZE
    ball.yV = -ball.yV * MOMENTUM
}
        </code></pre>   
        <h2>The element of chance</h2>
        <p>We can use a random function so that our ball starts in a different location and traveling in a different direction and speed each time we run our code by updating the initial values we define for our ball.</p>
        <p>The <code>x</code> value can be any number from zero to the width (minus the width of the ball) of the canvas but Math.random() produces a random value between 0 and 1 so if we multiply them together, we will get a random position at a particular percentage of the canvas width.</p>
        <p>For the <code>y</code> value we want to start the ball higher in the canvas so that it has space to fall and bounce so multiplying the random amount of 1 to a third of the height should work fine but feel free to experiment with these values.</p>
        <p>For the velocity values we can get a random number between 0 and 10 and then subtract 5 to get a number from -5 to +5.</p>
        <pre><code>
<i>let ball = {
    x:</i> Math.random() * (canvas.width - BALLSIZE)<i>, 
    xV:</i> Math.random() * 30 - 15<i>, 
    y:</i> Math.random() * (canvas.height / 3)<i>, 
    yV:</i> Math.random() * 30 - 15<i>
}</i>
        </code></pre>                   
        <p><i>NOTE: We can format the code for our object over multiple lines now to make it easier to read.</i></p>  
        <h2>Multi-ball</h2>
        <p>Computers are great at repeating things so let's use that power to get some more balls by:</p>
        <ul>
            <li>Adding another constant for the number of balls to use.
                <pre><code>
const TOTALBALLS = 2
                </code></pre>                   
            </li>
            <li>Rather than storing one <code>ball</code> in a variable we can store an array (list) of <code>balls</code>. To define an array we can use an empty list <code>[ ]</code> and then loop, counting to the <code>TOTALBALLS</code> value. With each loop we add a ball to the <code>balls</code> list.
                 The <code>push</code> method means push another item on the end of the array.
                <pre><code>
<i>//Define variables</i>
let balls = []
for(let i = 0; i < TOTALBALLS; i++) {

    <i>balls.push({
        x: Math.random() * (canvas.width - BALLSIZE), 
        xV: Math.random() * 30 - 15, 
        y: Math.random() * (canvas.height / 3), 
        yV: Math.random() * 30 - 15 
    })</i>

}                
                </code></pre>                   
            </li>
            <li>Inside our main loop we need to now update the positions for each ball in our list not just one ball. Using the <code>forEach</code> method this is easy. Wrap the existing code in the <code>Update values</code> section in the following:
                <pre><code>
<i>//Update values</i>
balls.forEach(ball => {      
    <i>...</i>
})
                </code></pre>   
                <p>This will run the updates we coded but now once for each ball in the list.  Another way to thing about <code>forEach</code> in this context is to say for each <code>ball</code> in my list of <code>balls</code> do something.
                </p>               
            </li>
            <li>Now we need to do the same for the <code>Redraw the screen</code> section to draw all of the balls not just one.
                <pre><code>
<i>//Redraw the screen
canvasContext.clearRect(0, 0, canvas.width, canvas.height)</i>

balls.forEach(ball => {
    <i>canvasContext.drawImage(ballImage, ball.x, ball.y, BALLSIZE, BALLSIZE)</i>
})
                </code></pre>   
            </li>
        </ul>
        <p>Now let's run the code to get 2 balls. If you need to check your code a full listing to this point is provided in the lesson Code a Game - Part 2.</p>
        <p>When things are working, and now that you have done the work to support 2 balls, let's get more. Just set <code>TOTALBALLS = 20</code> or what about 50, 100 or even 1000?. 
            It's here where you might get a sense of the power of coding where the coder plans, organises and prepares structures, shapes, designs and patterns but the computer does the work.</p>
        <script>
            let pos = localStorage.getItem(`scrollPos-${window.location.pathname}`)
            document.documentElement.scrollTop = pos
            window.addEventListener("scroll", (e) => {
                localStorage.setItem(`scrollPos-${window.location.pathname}`, document.documentElement.scrollTop)
            })
        </script>           
    </body>
</html>